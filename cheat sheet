### 递归算法以及eval()函数
```python
s = input().split()
def cal():
    cur = s.pop(0)
    if cur in "+-*/":
        return str(eval(cal() + cur + cal()))
    else:
        return cur
print("%.6f" % float(cal()))
```python
### 整数划分问题dp算法
```
dp = [0] * (50 + 1)  
dp[0] = 1  # 基础情况：有一种方式来分解 0  
for i in range(1, 50 + 1):  
    for j in range(i, 50 + 1):  
        dp[j] += dp[j - i]   
while True:
    try:
        n = int(input())
        ans = dp[n]
        print(ans)
    except EOFError:
        break
```
### 深度优先搜索（dfs）
```python
import sys
sys.setrecursionlimit(20000)
dx = [-1, -1, -1, 0, 0, 1, 1, 1]
dy = [-1, 0, 1, 1, -1, -1, 0, 1]
def dfs(x, y, field):
    field[x][y] = '.'
    for i in range(8):
        nx, ny = x + dx[i], y + dy[i]
        if 0 <= nx < N and 0 <= ny < M and\
              field[nx][ny] == 'W':
            dfs(nx, ny, field)
N, M = map(int, input().split())
field = []
for i in range(N):
    field.append(list(input()))
counter = 0
for i in range(N):
    for j in range(M):
        if field[i][j] == 'W':
            dfs(i, j, field)
            counter += 1
print(counter)
```
### 求排列的逆序数（二分归并）
```python
def mergeSort(arr):
    if len(arr) <= 1:
        return arr, 0
    mid = len(arr) // 2
    left, inv_count_left = mergeSort(arr[:mid])
    right, inv_count_right = mergeSort(arr[mid:])
    merged, inv_count = merge(left, right)
    inv_count += inv_count_left + inv_count_right
    return merged, inv_count
def merge(left, right):
    merged = []
    inv_count = 0
    i = j = 0
    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            merged.append(left[i])
            i += 1
        else:
            merged.append(right[j])
            j += 1
            inv_count += len(left) - i
    merged += left[i:]
    merged += right[j:]
    return merged, inv_count
# 输入排列
n = int(input())
arr = list(map(int, input().split()))
# 调用归并排序函数并输出逆序数
sorted_arr, inv_count = mergeSort(arr)
print(inv_count)
```
#滑动窗口解决最长子列
···python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        #滑动窗口
        char_map = {}
        left, max_length = 0, 0
        for right in range(len(s)):
            if s[right] in char_map and char_map[s[right]] >= left:
                left = char_map[s[right]] + 1
                char_map[s[right]] = right
            else:
                char_map[s[right]] = right
                max_length = max(max_length, right - left + 1)
        return max_length
    ans = lengthOfLongestSubstring
    print(ans)
```
